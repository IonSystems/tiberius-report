\section{Design and Implementation}

\subsection{Table definitions}
Each table has unique set of columns to suit the sensor data.
Every table has 2 columns in common. One is the id, this column represents the reading and provides a way to identify each reading. The first reading has id 1, and it increments with each reading. The other column in the timestamp, this is the time when the sensor data was inserted into the database - which is very close to the time the sensor data was aquired. Therefore the timestamp can be used to determine how old a sensor reading is.
\newline
Each table is defined in its own class.
Below is an example of the GPS table. The reason for the column names is expanded later in the GPS section.
\begin{lstlisting}[style=custompython]
class GPSTable(Table):
    table_name = "gps_reading"
    columns = {
        'id': 'int primary key',
        'latitude': 'float',
        'longitude': 'float',
        'altitude': 'float',
        'gps_qual': 'int',
        'num_sats': 'int',
        'dilution_of_precision': 'float',
        'velocity': 'float',
        'fixmode': 'int',
        'timestamp': 'float'}
\end{lstlisting}


\subsubsection{Ultrasonics}
The \gls{ultrasonicsensor} table has 6 columnns, one for each sensor. Each row in the table is a new reading of each sensor. The data represents the distance in millimeters to an object in its line of sight.
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htb]
\centering
\caption{ultrasonic table}
\label{tab:db-ultrasonics}
\begin{tabular}{@{}llllllll@{}}
\toprule
id              & fl    & fc    & fr    & rl    & rc    & rr    & timestamp \\ \midrule
int primary key & float & float & float & float & float & float & float
\end{tabular}
\end{table}
\begin{itemize}
\item{\textbf{fl}}: the sensor placed on the front left
\item{\textbf{fc}}: the sensor placed on the front centre 
\item{\textbf{fr}}: the sensor placed on the front right
\item{\textbf{rl}}: the sensor placed on the rear left 
\item{\textbf{rc}}: the sensor placed on the rear centre
\item{\textbf{rr}}: the sensor placed on the rear right 
\end{itemize}

\subsubsection{LIDAR}
\iffalse
\gls{LIDAR} data read using SDK (C++)
Changed the output to return a JSON format
Python dictionary in this format...
Small error with the last comma breaking the JSON object so used python \lstinline{data.replace(',\n' , ']')} which replaced the last comma with a ]

Lidar class validates the data
 - removes data (angle) which is obscured by the antenna
\fi



% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htb]
\centering
\caption{lidar table}
\label{tab:db-lidar}
\begin{tabular}{@{}lllllll@{}}
\toprule
id              & start\_flag & angle & distance & quality & reading\_iteration & timestamp \\ \midrule
int primary key & varchar     & float & float    & float   & int            & float
\end{tabular}
\end{table}
\begin{itemize}
\item{\textbf{start\_flag}}: a flag which is toggled on the last reading iteration of a full spin. It is included as it is produces by the SDK, however currently it is not used.
\item{\textbf{angle}}: the angle which the reading was taken at.
\item{\textbf{distance}}: the distance of an object that is line the lidar's line of sight.
\item{\textbf{qualitty}}: the measure of certanity that there is an object is that location
\item{\textbf{reading\_iteration}} increments after each full spin. This means that when querying the database, the user can ensure that all the readings come from the same 360 degree spin.
\end{itemize}


\subsubsection{GPS}

% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htb]
\centering
\caption{GPS table}
\label{tab:db-gps}
\begin{tabular}{@{}lllllllll@{}}
\toprule
id              & latitude & longitude & altitude & gps\_qual & num\_sats & velocity & fixmode & timestamp \\ \midrule
int primary key & float    & float     & float    & int       & int       & float    & int     & float
\end{tabular}
\end{table}
\begin{itemize}
\item{\textbf{latitude}}: the latitude specifies a location's distance north or south of the equator.
\item{\textbf{longitude}}: the longitude specifies the location's distance east or west of the Prime Meridian.
\item{\textbf{altitude}}: the height of the robotin relation to sea level or ground level.
\item{\textbf{gps\_qual}}: the value of the signal
\item{\textbf{num\_stats}}: the number of satellites the gps unit has communication with
\item{\textbf{velocity}}: the velocity which the robot is travelling at
\item{\textbf{fixmode}}: boolean value which represents whether the gps has a location or not.  
\end{itemize}


\subsubsection{Compass}
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htb]
\centering
\caption{Compass table}
\label{tab:db-compass}
\begin{tabular}{@{}lllllll@{}}
\toprule
id              & heading & tilt  & pitch & roll  & temperature & timestamp \\ \midrule
int primary key & float   & float & float & float & float       & float
\end{tabular}
\end{table}
\begin{itemize}
\item{\textbf{heading}}: the magnetic bearing that the front of the robot is pointing to
\item{\textbf{tilt}}: rotation around the vertical axis
\item{\textbf{pitch}}: rotation around the side to side axis
\item{\textbf{roll}}: rotation around the front to back axis
\item{\textbf{temperature}}: temperature reading of the compass
\end{itemize}


\subsubsection{Motors}
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htb]
\centering
\caption{Motors table}
\label{tab:db-motors}
\begin{tabular}{@{}llllll@{}}
\toprule
id              & front\_left & front\_right & rear\_left & rear\_right & timestamp \\ \midrule
int primary key & float       & float        & float      & float       & float
\end{tabular}
\end{table}
\begin{itemize}
\item{\textbf{front\_left}}: the speed the front left motor is set at
\item{\textbf{front\_right}}: the speed the front right motor is set at
\item{\textbf{rear\_left}}: the speed the rear left motor is set at
\item{\textbf{rear\_right}}: the speed the rear right motor is set at
\end{itemize}


\subsubsection{Steering}
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htb]
\centering
\caption{Steering table}
\label{tab:db-steering}
\begin{tabular}{@{}llllll@{}}
\toprule
id              & front\_left & front\_right & rear\_left & rear\_right & timestamp \\ \midrule
int primary key & float       & float        & float      & float       & float
\end{tabular}
\end{table}
\begin{itemize}
\item{\textbf{front\_left}}: the angle the front left wheel is set at
\item{\textbf{front\_right}}: the angle the front right wheel is set at
\item{\textbf{rear\_left}}:  the angle the rear left wheel is set at
\item{\textbf{rear\_right}}:  the angle the rear right wheel is set at
\end{itemize}

\subsubsection{Arm}
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htb]
\centering
\caption{Arm table}
\label{tab:db-arm}
\begin{tabular}{@{}llllllll@{}}
\toprule
id              & X     & Y     & Z     & waist & elbow & shoulder & timestamp \\ \midrule
int primary key & float & float & float & float & float & float    & float
\end{tabular}
\end{table}
\begin{itemize}
\item{\textbf{X}}: the x position of the gripper 
\item{\textbf{Y}}: the y position of the gripper
\item{\textbf{Z}}: the z position of the gripper
\item{\textbf{waist}}: the angle of the waist
\item{\textbf{elbow}}: the angle of the elbow
\item{\textbf{shoulder}}: the angle of the shoulder
\end{itemize}

\subsection{Creating database}
Several functions are called when creating the tables. On normal usage the table are created when start\_tiberius.py is run. In start Tiberius all the configured files are called




It is then created with unique columns described in the next subsections.

\begin{lstlisting}[style=custompython]
def drop_create(poly, table):
    '''
    Drop a table then create it, this ensures the table has the latest column
    definitions and is initiall free of any data.
    '''
    try:
        poly.drop(table.table_name)
    except poly.NoSuchTableError:
        # Table didn't exist previously, no worries!
        pass
    try:
        poly.create(
            table.table_name,
            table.columns
        )
    except poly.OperationalError:
        print "something went wrong... "
    except poly.TableAlreadyExistsError:
        print table.table_name + " already exists."
\end{lstlisting}
As can be seen the table is dropped before being created. This means is Tiberius was previously running and Tiberius had not been switched off

\subsection{Insert}
Insert is used to add a new row to of data to into a table. The data is packed into one variable using python dictionary. The data is then extracted by specifying the keyword, which the data is related to.  

\begin{lstlisting}[style=custompython]
def insert_gps_reading(poly, id, data):
    poly.insert(
        GPSTable.table_name,
        {
            'id': id,
            'latitude': data['latitude'],
            'longitude': data['longitude'],
            'gps_qual': data['gps_qual'],
            'num_sats': data['num_sats'],
            'dilution_of_precision': data['dilution_of_precision'],
            'velocity': data['velocity'],
            'fixmode': data['fixmode'],
            'timestamp': data['timestamp']
        }
    )
\end{lstlisting}
\subsection{Update}
Update is used whe only one value in a certain row needs changed, and all other rows remain the same. This is not currently used, as the need to alter a reading has never arised. 

\subsection{Overwrite}
Overwrite allow a compelete row to be overwritten with new information. The id remains the same, as the function calling overwrite has to use the id inorder to specify which row it wants overwrite.
\begin{lstlisting}[style=custompython]
def overwrite_gps_reading(poly, id, data):
    poly.update(
        GPSTable.table_name,
        {
            # 'id': id,
            'latitude': data['latitude'],
            'longitude': data['longitude'],
            'gps_qual': data['gps_qual'],
            'num_sats': data['num_sats'],
            'dilution_of_precision': data['dilution_of_precision'],
            'velocity': data['velocity'],
            'fixmode': data['fixmode'],
            'timestamp': time.time()
        },
        {
            'clause': 'WHERE',
            'data': [
                {
                    'column': 'id',
                    'assertion': '=',
                    'value': id
                }
            ]
        }
    )
\end{lstlisting}

\subsection{Polyhedra wrapper}





\subsection{Procedure}
\subsubsection{Starting database}
Upon start up the database will not be running. It is therefore necessary to run the start tiberius script to initiate the database and start the threads. The database is started using the command shown below.

\begin{lstlisting}[style=custompython]
database = Popen("/home/pi/poly9.0/linux/raspi/bin/rtrdb -r data_service=8001 db", shell=True, stdout=PIPE)
\end{lstlisting}

The tables for all the sensors are then created. This is done by calling the create function described above. Next the threads are started to continuously update the database. Threads are only started if the sensor is installed - this is ensured by the configuration file. For more detail on the configuration file see configuration  (\ref{configuration}). The motor and arm are actuators rather than sensors, and therefore are employ a different technique to update the value; this technique is further described in the Decorators section (\ref{decoratordefinition})

\subsubsection{Sensor threads}
Each sensor has its own thread; the purpose of which is to collect the data from the sensor it is assigned to. The threads run concurrently and have a their own time delay to reduce the workload.
Below is a shortened version of the GPS thread.
\begin{lstlisting}[style=custompython]
while True:
  gps_data = gps.read_gps()
  if gps_data is not False:
    if gps_read_id < GPS_NUMBER_OF_READINGS:
   		ins.insert_gps_reading(self.poly, gps_read_id, gps_data)
    else:  # start updating results
   		gps_update_id = gps_read_id % GPS_NUMBER_OF_READINGS
    	up.overwrite_gps_reading(self.poly, gps_update_id, gps_data)
    gps_read_id += 1
    no_data_time = 0
\end{lstlisting}

old data in the database is overwritten with new data TODO:fill this in

\subsubsection{Actuator decorators}
Unlike the sensors, the actuator database should not be updated in a

\label{decoratordefinition}
Decorators dynamically alter the functionality of a function, method or class without having to directly use subclasses \ref{decoratordefinition}.
